// libti99
#include <vdp.h>
#include <sound.h>
#include <kscan.h>

// game
#include "game.h"
#include "trampoline.h"
#include "music.h"

char * const cruiserText[] = {
	"NAME:   CRUISER ",
	"CLASS:  RQ-47   ",
	"SIZE:   TOO BIG ",
	"HEAVY DUTY SHIP ",
	"BATTLE-READY    "
};

char * const snowballText[] = {
	"NAME:   SNOWBALL",
	"CLASS:  SALVAGE ",
	"ARMOR:  NONE    ",
	"BOB SHUMWAY'S   ",
	"ORIGINAL FIGHTER"
};

char * const ladybugText[] = {
	"NAME: LADYBIRD  ",
	"ORDER:COLEOPTERA",
	"GENUS:COCCINELLI",
	"FOR THE DELICATE",
	"PILOT           "
};

char * const gnatText[] = {
	"NAME:   GNAT    ",
	"POWERUP:NONE    ",
	"SHIELD: WARPONLY",
	"ANNOYING INSECT ",
	"HARD TO HIT     "
};

char * const selenaText[] = {
	"NAME:   SELENA  ",
	"RANK:   PRINCESS",
	"MAGIC:  LEVEL 99",
	"THE FUN HAS BEEN",
	"DOUBLED         "
};

// simple sound test
char * const musText[] = {
	"MUSIC TEST",
	"PRESS BUTTON ON KEYPAD",
	"PRESS FIRE TO EXIT"
};

const unsigned char SCHEMATICS[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// cruiser top
	0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x26,
	0x0F,0x10,0x20,0x4F,0x90,0xA0,0xA0,0xA0,
	0x40,0x40,0x40,0x40,0x80,0x8F,0xF0,0x00,
	0xF0,0x08,0x04,0xF2,0x09,0x05,0x05,0x05,
	0x02,0x02,0x02,0x02,0x01,0xF1,0x0F,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x80,0x80,0x80,0x80,0x40,0x40,0x40,0x64,
	0x5A,0x42,0x24,0x28,0x30,0x20,0x40,0x40,
	0x40,0x40,0x40,0x40,0x40,0x43,0x4C,0x30,
	0x8A,0xBA,0x80,0x88,0x81,0x88,0x41,0x48,
	0x41,0x48,0x21,0x24,0xFF,0x18,0x20,0x3F,
	0x51,0x5D,0x01,0x11,0x81,0x11,0x82,0x12,
	0x82,0x12,0x84,0x24,0xFF,0x18,0x04,0xFC,
	0x5A,0x42,0x24,0x14,0x0C,0x04,0x02,0x02,
	0x02,0x02,0x02,0x02,0x02,0xC2,0x32,0x0C,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// cruiser side
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x7F,0x40,0x20,0x20,0x40,0xD2,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0xC0,0x20,0x10,0x08,0x04,0x4A,0x02,
	0x00,0x03,0x0C,0x30,0x4F,0x80,0x80,0x40,
	0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xC4,0x04,0x08,0x30,0xC1,0x00,0x01,0x00,
	0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xBF,0x60,0x9F,0x00,
	0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x02,0x02,0x01,0x01,0xFD,0x05,0x02,0xF9,
	0xC7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// snowball top
	0x00,0x00,0x00,0x00,0x00,0x02,0x05,0x05,
	0x01,0x02,0x02,0x02,0x02,0x04,0x05,0x04,
	0x05,0x08,0x08,0x08,0x08,0x14,0x24,0x44,
	0x80,0x40,0x40,0x40,0x40,0x20,0xA0,0x20,
	0xA0,0x10,0x10,0x10,0x10,0x28,0x24,0x22,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x40,0xA0,0xA0,
	0x05,0x05,0x04,0x04,0x08,0x11,0x11,0x11,
	0x11,0x10,0x10,0x10,0x10,0x11,0x12,0x0C,
	0x84,0x04,0x04,0x05,0x84,0x45,0xC4,0x45,
	0x44,0x05,0x04,0x74,0x8F,0x04,0x08,0x0F,
	0x21,0x20,0x20,0xA0,0x21,0xA2,0x23,0xA2,
	0x22,0xA0,0x20,0x2E,0xF1,0x20,0x10,0xF0,
	0xA0,0xA0,0x20,0x20,0x10,0x88,0x88,0x88,
	0x88,0x08,0x08,0x08,0x08,0x88,0x48,0x30,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// snowball side
	0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x08,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x87,0x78,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x03,0x04,0x08,0xFF,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0xFE,0x04,0x08,0xFA,0x06,
	0x13,0x7C,0x80,0x78,0x07,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x80,0x00,0x0F,0x02,0x81,0x7F,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0xFF,0x00,0x00,0x81,0x40,0x3F,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x1A,0x12,0xF2,0x0A,0xA6,0x51,0x01,0xFF,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// ladybug top
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x12,0x2D,0x14,0x0A,0x15,0x10,0x20,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x48,0xB4,0x28,0x50,0xA8,0x08,0x04,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x41,0x44,0x51,0x40,0x49,0x20,0x11,0x08,
	0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x82,0x22,0x8A,0x02,0x92,0x04,0x88,0x10,
	0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// ladybug side
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x01,0x07,0x19,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0xF8,0x04,0x42,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x02,0x01,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x22,0x7C,0x80,0xD0,0x45,0x30,0x0F,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x0A,0x21,0x01,0x05,0x51,0x06,0xF8,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// gnat top
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x01,0x03,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// gnat side
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// selena top
	0x00,0x06,0x09,0x30,0x40,0x80,0x80,0x80,
	0x00,0x01,0x01,0x07,0x09,0x11,0x11,0x16,
	0x08,0x08,0x88,0x68,0x1E,0x11,0x21,0x20,
	0x80,0x40,0x78,0x24,0x12,0x0A,0x0C,0x08,
	0x04,0x04,0x25,0x12,0x10,0x10,0x20,0x20,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x30,0xC8,0x04,0x02,0x01,0x01,0x01,
	0xBB,0x44,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x70,0x8F,0x08,0x08,0x30,0x40,0x40,0x46,
	0x46,0x38,0x10,0x21,0x21,0x20,0x10,0x0F,
	0x46,0x89,0x08,0x30,0x28,0x28,0x18,0x18,
	0x18,0x10,0xD0,0x30,0x30,0x20,0xC0,0x00,
	0x6D,0x92,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// selena side
	0x83,0x6C,0x50,0x28,0x28,0xC4,0x82,0x79,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x07,0xC8,0x30,0x20,0x40,0x40,0x20,0xE0,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x80,0x40,0xB0,0x88,0x44,0x88,0xF1,0x4E,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x70,0x8C,0x02,0x31,
	0x04,0x04,0x02,0x0E,0x33,0x24,0x12,0x0B,
	0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x20,0x10,0x00,0x80,0x20,0x7F,0x80,0x40,
	0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x42,0x83,0xA2,0x22,0x1A,0xF9,0x06,0x01,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x49,0xA9,0x51,0x42,0x44,0xB8,0x60,0x90,
	0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

void soundtest() {
	unsigned char r;

	cls();
	for (r=1; r<7; r+=2) {
		centr(r, musText[r>>1]);
	}
	wrapinitstars();

	for (;;) {
		waitforstep();
		screen(COLOR_MEDRED);

		kscanfast(joynum);	// all keys except '*' are okay (cause we are called with '*' down)

		if (KSCAN_KEY != 0xff) {
			shutup();
		}

		switch (KSCAN_KEY) {
		case JOY_FIRE:	
			screen(COLOR_DKBLUE);
			return;

		case '1':
			StartMusic(STAGE1MUS, 1);
			break;

		case '2':
			StartMusic(STAGE2MUS, 1);
			break;

		case '3':
			StartMusic(STAGE3MUS, 1);
			break;

		case '4':
			StartMusic(STAGE4MUS, 1);
			break;

		case '5':
			StartMusic(STAGE5MUS, 1);
			break;

		case '6':
			StartMusic(BOSSMUS, 1);
			break;

		case '7':
			StartMusic(GAMEOVERMUS, 0);
			break;

		case '8':
			StartMusic(WINSCROLLMUS, 1);
			break;

		// TODO: this is probably too obvious to keep it?
		case '0':
			nDifficulty = DIFFICULTY_HARD;
			wrapGamWin();
		}

		// just for fun, and don't incude in timing
		screen(COLOR_DKBLUE);
		wrapbackground();		// for stars
	}
}

// selects difficulty
char * const sSkillText[] = {
	"TO SELECT GAME OPTION,",
	"PRESS BUTTON ON KEYPAD",
	"",
	"1 = SKILL 1/ONE PLAYER",
	"2 = SKILL 2/ONE PLAYER",
	"3 = SKILL 3/ONE PLAYER",
	"","",
	"LEFT/RIGHT TO SELECT SHIP:"
};

void getDifficulty() {
	unsigned char r,c;
	char *pTxt;
	unsigned char txtIdx;
	unsigned char oldJoy=0xff;
	unsigned char cnt = 0;
	const unsigned char *pGfx;
	unsigned char gfxCnt;

	// update default
	if (playership == 255) playership = SHIP_CRUISER;

	// the schematic should be gray
	vdpchar(gCOLOR+16, 0xe0);
	VDP_SAFE_DELAY();
	vdpchar(gCOLOR+17, 0xe0);
	VDP_SAFE_DELAY();
	vdpchar(gCOLOR+18, 0xe0);
	VDP_SAFE_DELAY();
	vdpchar(gCOLOR+19, 0xe0);

redraw:
	cls();
	txtIdx = 0;
	for (r=1; txtIdx<9; r+=2) {
		if (sSkillText[txtIdx][0] == '\0') {
			--r;	// skip 1 line instead of 2
		} else {
			centr(r, sSkillText[txtIdx]);
		}
		++txtIdx;
	}

redraw2:
	vdpmemset(gIMAGE+16*32, 32, 8*32);	// partial screen clear
	txtIdx = 0;
	r=17;
	c=2;

	// erase the characters we're going to use (16 chars from 128-143)
	// and two sprites (0 and 1)
	vdpmemset(gPATTERN+(128*8), 0, 32*8);
	vdpmemset(gSPRITE_PATTERNS, 0, 8*8);

	vdpmemcpy(VDP_SCREEN_POS(18,19), "\x80\x82\x84\x86  \x90\x92\x94\x96", 10);
	vdpmemcpy(VDP_SCREEN_POS(19,19), "\x81\x83\x85\x87  \x91\x93\x95\x97", 10);
	vdpmemcpy(VDP_SCREEN_POS(20,19), "\x88\x8a\x8c\x8e  \x98\x9a\x9c\x9e", 10);
	vdpmemcpy(VDP_SCREEN_POS(21,19), "\x89\x8b\x8d\x8f  \x99\x9b\x9d\x9f", 10);

	switch (playership) {
	default:
	case SHIP_CRUISER:
		pTxt = cruiserText[txtIdx];
		pGfx = &SCHEMATICS[0];
		break;

	case SHIP_SNOWBALL:
		pTxt = snowballText[txtIdx];
		pGfx = &SCHEMATICS[256];
		break;

	case SHIP_LADYBUG:
		pTxt = ladybugText[txtIdx];
		pGfx = &SCHEMATICS[512];
		break;

	case SHIP_GNAT:
		pTxt = gnatText[txtIdx];
		pGfx = &SCHEMATICS[768];
		break;

	case SHIP_SELENA:
		pTxt = selenaText[txtIdx];
		pGfx = &SCHEMATICS[1024];
		break;
	}
	gfxCnt = 0;

	// no cheat by default
	ch=0;	

	for (;;) {
		waitforstep();
		++cnt;

		// set background to blue (also resets after music test)
		screen(COLOR_DKBLUE);

		kscanfast(joynum);
		if ((KSCAN_KEY > '0') && (KSCAN_KEY < '4')) {
			// hold up while selecting to enable cheat mode
			joystfast(joynum);
			if (KSCAN_JOYY == JOY_UP) {
				ch=1;
			}
			switch (KSCAN_KEY) {
				case '1':	
					nDifficulty = DIFFICULTY_EASY;
					break;

				case '2':	
					nDifficulty = DIFFICULTY_MEDIUM;
					break;

				case '3':	
					nDifficulty = DIFFICULTY_HARD;
					break;
			}
			if (playership == SHIP_GNAT) scoremode = 1;
			if (playership == SHIP_SELENA) scoremode = 2;
			if ((playership == SHIP_SNOWBALL) && (KSCAN_JOYY == JOY_DOWN)) scoremode = 3;
			if (ch) scoremode = 9;

			spdel(0);
			spdel(1);

			break;
		}
		if (KSCAN_KEY == '*') {
			spdel(0);
			spdel(1);

			soundtest();
			goto redraw;
		}

		// handle the ship select at the bottom
		joystfast(joynum);
		if (KSCAN_JOYX != oldJoy) {
			oldJoy = KSCAN_JOYX;
			if (KSCAN_JOYX == JOY_LEFT) {
				--playership;
				kscanfast(joynum);
				if (KSCAN_KEY == JOY_FIRE) {
					if (playership > SHIP_SELENA) playership = SHIP_SELENA;
				} else {
					if (playership > SHIP_LADYBUG) playership = SHIP_LADYBUG;
				}
				goto redraw2;
			}
			if (KSCAN_JOYX == JOY_RIGHT) {
				++playership;
				kscanfast(joynum);
				if (KSCAN_KEY == JOY_FIRE) {
					if (playership > SHIP_SELENA) playership = SHIP_CRUISER;
				} else {
					if (playership > SHIP_LADYBUG) playership = SHIP_CRUISER;
				}
				goto redraw2;
			}
		}

		// handle some drawing
		if (txtIdx <= 4) {
			// if not finished
			if (cnt & 1) {
				// update info text
				vdpchar(VDP_SCREEN_POS(r,c), *pTxt);
				++c;
				++pTxt;
				if (*pTxt != '\0') {
					VDPWD = '_';
				} else {
					txtIdx++;
					if (txtIdx <= 4) {
						++r;
						if (r == 20) ++r;	// one blank row
						c=2;
						switch (playership) {
						case SHIP_CRUISER:
							pTxt = cruiserText[txtIdx];
							break;

						case SHIP_SNOWBALL:
							pTxt = snowballText[txtIdx];
							break;

						case SHIP_LADYBUG:
							pTxt = ladybugText[txtIdx];
							break;

						case SHIP_GNAT:
							pTxt = gnatText[txtIdx];
							break;

						case SHIP_SELENA:
							pTxt = selenaText[txtIdx];
							break;
						}
					}
				}
			} else {
				// update schematic display (80 frames total)
				// 0-31		draw vertical
				// 32-47	delay
				// 48-79	draw horizontal

				if (gfxCnt < 32) {
					// top to bottom scan
					unsigned int pOut = ((gfxCnt < 16) ? 0 : 48) + gfxCnt;	// character offset
					unsigned char tmp;

					tmp = *(pGfx+pOut);
					vdpchar(gPATTERN+pOut+(128*8), tmp);		// should be enough math to keep VDP timing safe
					vdpchar(gSPRITE_PATTERNS, tmp | (tmp<<1) | (tmp>>1));
					vdpchar(gSPRITE_PATTERNS+1, tmp | (tmp<<1) | (tmp>>1));

					tmp=*(pGfx+pOut+16);
					vdpchar(gPATTERN+pOut+(128*8)+16, tmp);
					vdpchar(gSPRITE_PATTERNS+(2*8), tmp | (tmp<<1) | (tmp>>1));
					vdpchar(gSPRITE_PATTERNS+(2*8)+1, tmp | (tmp<<1) | (tmp>>1));

					tmp=*(pGfx+pOut+32);
					vdpchar(gPATTERN+pOut+(128*8)+32, tmp);					
					vdpchar(gSPRITE_PATTERNS+(4*8), tmp | (tmp<<1) | (tmp>>1));
					vdpchar(gSPRITE_PATTERNS+(4*8)+1, tmp | (tmp<<1) | (tmp>>1));

					tmp=*(pGfx+pOut+48);
					vdpchar(gPATTERN+pOut+(128*8)+48, tmp);		
					vdpchar(gSPRITE_PATTERNS+(6*8), tmp | (tmp<<1) | (tmp>>1));
					vdpchar(gSPRITE_PATTERNS+(6*8)+1, tmp | (tmp<<1) | (tmp>>1));

					sprite(0,0,COLOR_WHITE,gfxCnt+143,152);
					sprite(1,4,COLOR_WHITE,gfxCnt+143,168);

					// there's a VDP beam race here -- the pattern is updated before the frame finishes
					// drawing, so gets the new pattern, then the position is updated NEXT frame.
					// We can't just directly update sprites 0 and 1 because the sprite rotation means
					// we never know where they really land.
					// to avoid the weirdness, we'll just recopy the sprite table (slowly) here
					// It's messy but takes little code and little enough time. The hardware sprites
					// will still shuffle around but we won't see it.
					vdpmemcpy(gSPRITES, (void*)SpriteTab, 128);

				} else if (gfxCnt < 47) {
					// delay (just clean up the sprites while we wait - it's okay it's repeated)
					// short by one frame so we finish before the text does
					spdel(0);
					spdel(1);
					vdpmemset(gSPRITE_PATTERNS, 0, 8*8);
				} else if (gfxCnt < 79) {
					// left to right scan
					unsigned char loop;
					unsigned char idx = gfxCnt - 47;
					unsigned char off = (idx>>3)<<4;	// character count
					unsigned char mask;
					idx &= 0x07;						// pixel offset
					mask = 0x80 >> idx;

					if (idx == 0) {
						memset(tmpbuf, 0, 32);
					}

					for (loop = 0; loop < 16; loop++) {
						unsigned char tmp = (*(pGfx+(int)128+off+loop)) & mask;
						tmpbuf[loop] |= tmp;
						vdpchar(gPATTERN+off+(144*8)+loop, tmpbuf[loop]);

						if (tmp) {
							if (loop > 0) {
								// comparison so that we only OR upwards
								vdpchar(gSPRITE_PATTERNS+loop-1, 0x80);
							}
							vdpchar(gSPRITE_PATTERNS+loop, 0x80);
							if (loop < 15) {
								vdpchar(gSPRITE_PATTERNS+loop+1, 0x80);
							}
						} else {
							if (loop == 0) {
								vdpchar(gSPRITE_PATTERNS+loop, 0x00);
							}
							if (loop < 15) {
								vdpchar(gSPRITE_PATTERNS+loop+1, 0x00);
							}
						}
					}
					for (loop = 0; loop < 16; loop++) {
						// 128+64 compiled to a -64 instead of +64... assembly looked okay,
						// just an 8 bit wraparound issue? Promotion doesn't help, but
						// using "192" instead did...
						unsigned char tmp = (*(pGfx+192+off+loop)) & mask;
						tmpbuf[loop+16] |= tmp;
						vdpchar(gPATTERN+off+(144*8)+64+loop, tmpbuf[loop+16]);

						if (tmp) {
							if (loop > 0) {
								vdpchar(gSPRITE_PATTERNS+loop-1+64, 0x80);
							}
							vdpchar(gSPRITE_PATTERNS+loop+32, 0x80);
							if (loop < 15) {
								vdpchar(gSPRITE_PATTERNS+loop+1+32, 0x80);	
							}
						} else {
							if (loop == 0) {
								vdpchar(gSPRITE_PATTERNS+loop+32, 0x00);
							}
							if (loop < 15) {
								vdpchar(gSPRITE_PATTERNS+loop+1+32, 0x00);	
							}
						}
					}

					sprite(0,0,COLOR_WHITE,143,200+(gfxCnt-47));
					sprite(1,4,COLOR_WHITE,159,200+(gfxCnt-47));

					// same VDP race workaround as above
					vdpmemcpy(gSPRITES, (void*)SpriteTab, 128);
				}
				++gfxCnt;
				if (gfxCnt == 128) gfxCnt = 0;
			}
		} else {
			spdel(0);
			spdel(1);
		}
	}
}
